<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Шежіре Онлайн</title>
<style>
body { font-family: Arial, sans-serif; background:#f4f6f8; margin:0; padding:0; }
header { background:#1f2937; color:white; padding:15px; font-size:22px; text-align:center; font-weight:bold; }
button { margin:10px 20px; padding:10px 15px; font-weight:bold; border:none; border-radius:5px; background:#1f2937; color:white; cursor:pointer; }
button:hover { background:#111827; }
#treeContainer { width:100%; height:85vh; overflow:auto; }
.node rect { fill:#3498db; stroke:#555; stroke-width:1.5px; rx:10; ry:10; cursor:pointer; }
.node text { fill:white; font-weight:bold; font-size:14px; pointer-events:none; }
.node.green rect { fill:#2ecc71; }
.link { fill:none; stroke:#555; stroke-width:2px; }
</style>
</head>
<body>

<header>Шежіре Онлайн</header>
<button id="resetBtn">Сбросить дерево</button>
<div id="treeContainer"></div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
const API_URL = "https://script.google.com/macros/s/AKfycbzPSTf_4Tdq4xq8C1pwBYrx33F28MOEYKhwgVFcJ4TP5LYFKhhCaQ8IR44EFkadCW6U/exec";

let rootData = null;

const width = 1200;
const height = 800;
const duration = 500;

const svg = d3.select("#treeContainer").append("svg")
    .attr("width", width)
    .attr("height", height)
    .append("g")
    .attr("transform", "translate(50,50)");

let treeLayout = d3.tree().size([height - 100, width - 200]);

// Загрузка данных и построение дерева
async function loadTree() {
    const res = await fetch(API_URL);
    const people = await res.json();

    const map = {};
    people.forEach(p => map[p.id] = {...p, children: []});
    let rootPerson = null;
    people.forEach(p => {
        if(p.father_id === "" || p.father_id === null) rootPerson = map[p.id];
        else if(map[p.father_id]) map[p.father_id].children.push(map[p.id]);
    });

    if(!rootPerson){ document.getElementById("treeContainer").innerText="Ошибка: не найден главный предок"; return; }

    rootData = d3.hierarchy(rootPerson, d => d.children);
    rootData.x0 = height / 2;
    rootData.y0 = 0;

    // Изначально сворачиваем все узлы кроме корня
    rootData.children.forEach(collapse);

    update(rootData);
}

// Сворачивание узла
function collapse(d){
    if(d.children){
        d._children = d.children;
        d._children.forEach(collapse);
        d.children = null;
    }
}

// Разворачивание узла
function expand(d){
    if(d._children){
        d.children = d._children;
        d.children.forEach(expand);
        d._children = null;
    }
}

function update(source){
    const treeData = treeLayout(rootData);

    const nodes = treeData.descendants();
    const links = treeData.links();

    nodes.forEach(d => { d.y = d.depth * 180; });

    // **************** Nodes ****************
    let node = svg.selectAll("g.node")
        .data(nodes, d => d.data.id);

    const nodeEnter = node.enter().append("g")
        .attr("class","node")
        .attr("transform", d => `translate(${source.y0},${source.x0})`)
        .on("click", (event,d) => {
            if(d.children){
                d._children = d.children;
                d.children = null;
            } else {
                d.children = d._children;
                d._children = null;
            }
            update(d);
        });

    nodeEnter.append("rect")
        .attr("width", 120)
        .attr("height", 40)
        .attr("x", -60)
        .attr("y", -20)
        .attr("rx", 10)
        .attr("ry", 10)
        .attr("class", d => d.data.color);

    nodeEnter.append("text")
        .attr("dy", 5)
        .attr("text-anchor","middle")
        .text(d => d.data.name);

    const nodeUpdate = nodeEnter.merge(node);

    nodeUpdate.transition()
        .duration(duration)
        .attr("transform", d => `translate(${d.y},${d.x})`);

    nodeUpdate.select("rect")
        .attr("class", d => d.data.color);

    // Remove old nodes
    const nodeExit = node.exit().transition()
        .duration(duration)
        .attr("transform", d => `translate(${source.y},${source.x})`)
        .remove();

    nodeExit.select("rect").attr("width",0).attr("height",0);
    nodeExit.select("text").style("fill-opacity",0);

    // **************** Links ****************
    const link = svg.selectAll("path.link")
        .data(links, d => d.target.data.id);

    const linkEnter = link.enter().insert("path","g")
        .attr("class","link")
        .attr("d", d => {
            const o = {x: source.x0, y: source.y0};
            return diagonal(o,o);
        });

    const linkUpdate = linkEnter.merge(link);
    linkUpdate.transition().duration(duration).attr("d", d => diagonal(d.source,d.target));

    const linkExit = link.exit().transition()
        .duration(duration)
        .attr("d", d => {
            const o = {x: source.x, y: source.y};
            return diagonal(o,o);
        })
        .remove();

    nodes.forEach(d => { d.x0 = d.x; d.y0 = d.y; });
}

// Диагональные линии
function diagonal(s,t){
    return `M ${s.y} ${s.x} C ${(s.y+t.y)/2} ${s.x}, ${(s.y+t.y)/2} ${t.x}, ${t.y} ${t.x}`;
}

// Сброс дерева
document.getElementById("resetBtn").onclick = () => {
    rootData.children.forEach(collapse);
    rootData.children = rootData._children || rootData.children;
    update(rootData);
};

loadTree();
</script>

</body>
</html>
