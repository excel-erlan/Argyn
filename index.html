<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Шежіре</title>
<script src="https://d3js.org/d3.v7.min.js"></script>

<style>
  body { font-family: Arial, sans-serif; margin: 0; padding: 0; background: #f4f6f8; }
  header { background: #1f2937; color: white; padding: 15px; font-size: 20px; text-align: center; font-weight: bold; }

  #treeContainer {
    width: 100%;
    height: 90vh;
    overflow: auto;
    border-top: 1px solid #ddd;
    background: white;
  }

  .node rect {
    cursor: pointer;
    stroke: #2c3e50;
    stroke-width: 1.5px;
  }

  .green { fill: #2ecc71; }
  .blue { fill: #3498db; }

  .node text {
    font: 14px sans-serif;
    fill: white;
    text-anchor: middle;
    dominant-baseline: middle;
    pointer-events: none;
  }

  .link {
    fill: none;
    stroke: #555;
    stroke-width: 2px;
  }

  #resetBtn {
    margin: 10px;
    padding: 8px 12px;
    background:#1f2937;
    color:white;
    border:none;
    border-radius:5px;
    cursor:pointer;
  }

  #resetBtn:hover { background:#2c3e50; }
</style>
</head>

<body>
<header>Шежіре Онлайн</header>
<button id="resetBtn">Сбросить дерево</button>
<div id="treeContainer"></div>

<script>
const API_URL = "https://script.google.com/macros/s/AKfycbzPSTf_4Tdq4xq8C1pwBYrx33F28MOEYKhwgVFcJ4TP5LYFKhhCaQ8IR44EFkadCW6U/exec";

let allData = [];
let rootData;
let svg, g, treeLayout;
let duration = 500;

// ID дедов (сюда свои реальные id)
const grandfathers = ["id1","id2","id3"];

async function loadData() {
    const res = await fetch(API_URL);
    allData = await res.json();

    // ставим цвет дедам
    allData.forEach(d => {
        d.color = grandfathers.includes(d.id) ? "green" : "blue";
    });

    const root = buildHierarchy(allData);
    rootData = d3.hierarchy(root);

    rootData.x0 = 0;
    rootData.y0 = 0;

    // свернуть всех детей кроме корня
    if (rootData.children) rootData.children.forEach(collapse);

    createSvg();
    update(rootData);

    // ставим скролл наверх и влево
    const container = document.getElementById("treeContainer");
    container.scrollTop = 0;
    container.scrollLeft = 0;
}

// строим дерево из плоских данных
function buildHierarchy(data) {
    let idMap = {};
    data.forEach(d => { idMap[d.id] = {...d, children: []}; });

    let root;
    data.forEach(d => {
        if(d.father_id === "" || d.father_id === null) {
            root = idMap[d.id];
        } else {
            if(idMap[d.father_id]) idMap[d.father_id].children.push(idMap[d.id]);
        }
    });

    return root;
}

// сворачиваем узлы
function collapse(d) {
    if(d.children){
        d._children = d.children;
        d._children.forEach(collapse);
        d.children = null;
    }
}

// создаем svg
function createSvg() {
    const container = d3.select("#treeContainer");
    container.selectAll("*").remove();

    svg = container.append("svg")
        .attr("width", 2000)   // временно
        .attr("height", 2000); // временно

    g = svg.append("g")
        .attr("transform", "translate(50,50)");

    treeLayout = d3.tree().nodeSize([120, 180]);
}

// обновление дерева
function update(source) {
    const treeData = treeLayout(rootData);
    const nodes = treeData.descendants();
    const links = treeData.links();

    // нормализуем Y
    nodes.forEach(d => { d.y = d.depth * 180; });

    // поднимаем дерево вверх (чтобы верх всегда был виден)
    const minX = d3.min(nodes, d => d.x);
    nodes.forEach(d => { d.x = d.x - minX; });

    // LINKS
    const link = g.selectAll(".link")
        .data(links, d => d.target.data.id);

    link.enter()
        .append("path")
        .attr("class", "link")
        .attr("d", d => diagonal(source, source))
        .transition().duration(duration)
        .attr("d", d => diagonal(d.source, d.target));

    link.transition().duration(duration)
        .attr("d", d => diagonal(d.source, d.target));

    link.exit().remove();

    // NODES
    const node = g.selectAll(".node")
        .data(nodes, d => d.data.id);

    const nodeEnter = node.enter()
        .append("g")
        .attr("class", "node")
        .attr("transform", d => `translate(${source.y0},${source.x0})`)
        .on("click", (event, d) => { toggleChildren(d); update(d); });

    nodeEnter.append("rect")
        .attr("width", 120)
        .attr("height", 40)
        .attr("rx", 10)
        .attr("ry", 10)
        .attr("class", d => d.data.color);

    nodeEnter.append("text")
        .attr("dx", 60)
        .attr("dy", 20)
        .text(d => d.data.name);

    const nodeUpdate = nodeEnter.merge(node);

    nodeUpdate.transition().duration(duration)
        .attr("transform", d => `translate(${d.y},${d.x})`);

    nodeUpdate.select("rect")
        .attr("class", d => d.data.color);

    node.exit().remove();

    nodes.forEach(d => { d.x0 = d.x; d.y0 = d.y; });

    // РЕАЛЬНЫЙ размер SVG (чтобы был scroll вправо/вниз)
    const maxX = d3.max(nodes, d => d.x) + 200;
    const maxY = d3.max(nodes, d => d.y) + 300;

    svg.attr("width", maxY)
       .attr("height", maxX);
}

// линия
function diagonal(s, d) {
    return `M ${s.y + 120},${s.x + 20}
            C ${(s.y + d.y)/2 + 120},${s.x + 20}
              ${(s.y + d.y)/2 + 120},${d.x + 20}
              ${d.y},${d.x + 20}`;
}

// открыть/закрыть
function toggleChildren(d) {
    if(d.children){
        d._children = d.children;
        d.children = null;
    } else {
        d.children = d._children;
        d._children = null;
    }
}

// кнопка сброса
document.getElementById("resetBtn").onclick = () => {
    if(rootData.children) rootData.children.forEach(collapse);
    update(rootData);

    const container = document.getElementById("treeContainer");
    container.scrollTop = 0;
    container.scrollLeft = 0;
};

loadData();
</script>
</body>
</html>
